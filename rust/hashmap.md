## 算法
* AHash：HashBrown默认hasher，比 SipHash 快得多。但是，AHash 不提供与 SipHash 相同级别的 HashDoS 抵抗能力，不是加密安全的哈希。
* SipHash：std默认hasher（未来考虑替换），对于整数等小键以及长字符串等大键性能一般，但是有良好的 HashDoS 抵抗能力。

## 数据结构
数据存放在一个个连续的桶中，定位时桶下标=hash%容量，因此扩容意味着重新分配内存重新计算下标。  
插入时如果计算的下标出现冲突，通常有以下几种解决方案：
* 开放定址法
  从发生冲突的那个单元起，按照一定的次序，找到一个空闲的单元放置数据。  
  缺点在于删除元素的时候不能真的删除，否则会引起查找错误，只能做一个特殊标记。只到有下个元素插入才能真正删除该元素。
  这个次序可以是+1可以是1²、 2²可以是另一种散列值
* 链地址法（拉链法）
  桶里放的是单链表(c++ stl，jdk在元素多了后会换成红黑树)。  
  内存利用率高，但是因为内存不连续cpu cache命中率低
* 再哈希法
  冲突时换另一种hash
* 建立公共溢出区
  将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。
  
Rust std1.36后采用了google的SwissTable，碰撞处理方式使用开放寻址，地址探测方法是在分块内部做平方探测
  
[一个仿照ClickHouse的哈希表设计](https://blog.csdn.net/RA681t58CJxsgCkJ31/article/details/124395157)